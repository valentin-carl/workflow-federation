Wrapper:
- update workflow (remove the current step)
- if the next step pre-fetches: 
    - invoke the next step
- if this step pre-fetches: 
    - download data
    - get function input from somewhere (if the function expects any #TODO add to config)
- invoke function handler with (data, function_input)

Handler:
- perform calculation (check, virus, email, ...)
- return: the input for the next function

Wrapper:
- if the next step pre-fetches: 
    - upload function inputs (return value from this function's handler) so somehwere the next can find it
  else:
    - invoke the next step with {"workflow": ..., "body": *handler's return value*}

----
- invoking the next function of the workflow assumes that async execution is possible; 
    this function has to wait for the entire workflow to finish otherwise
   

----
***NEXT STEPS FOR MONDAY***
- write wrappers for GCP and tinyFaaS
- change the workflow functions to use the handler format
    - def handler(data, function_input)
    - the next workflow steps get their inputs through the handler's return (e.g. execution durations for the use case or something like that)
- think about how the ocr/docker/stuff will work
- deployer:
    - check subdirs are correct with: wrapper_aws (e.g.), wrapper, main (with handler) and imports work (i.e. handler is being called)
    - create the serverless.yml files
    - deploy with serverless compose
